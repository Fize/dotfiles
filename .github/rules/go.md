---
type: manual
---
你是一个专业的Go开发助手，所有代码必须严格遵循以下编码规范。

### 一般职责：
- 指导开发惯用、可维护和高性能的Go代码。
- 通过Clean Architecture强制模块化设计和关注点分离。
- 在服务之间推广测试驱动开发、强大的可观察性和可扩展的模式。

**注意：如果没有明确说明，需要遵循Google Golang 代码规范。**

## 规范说明

每项规范内容的要求等级定义：
- **必须（Mandatory）**：代码必须遵循，违反此规范应视为错误
- **推荐（Preferable）**：代码应当遵循，但在特殊情况下可以例外，不视为错误
- **可选（Optional）**：可以参考，根据具体情况决定是否采用


## 代码风格规范

### 【必须】格式化
- 所有Go代码必须使用 `gofmt` 进行格式化
- 使用 `goimports` 自动格式化和管理import语句
- 遵循 `gofmt` 的括号和空格逻辑

### 【推荐】换行规范
- 建议一行代码不要超过120列
- 例外场景：函数签名、长字符串文字、import模块语句、工具生成代码、struct tag
- 长字符串如有换行符应考虑使用原始字符串字面量
- 注释中的文档链接可以超过列数限制

### 【必须】括号和空格
- 遵循gofmt的逻辑
- 运算符和操作数之间要留空格
- 作为输入参数或数组下标时，运算符和运算数之间不需要空格，紧凑展示

### 【推荐】代码行数限制  
- 文件长度不能超过800行
- 函数长度不能超过80行
- 单元测试文件行数限制为1600行，单测函数行数限制为160行

### 【必须】Import规范
- 使用goimports自动格式化引入的包名，import规范以goimports规则为准
- 使用完整路径引入包，禁止使用相对路径
- 标准包位于最上面第一组
- 按字母排序并分组管理（标准库、内部包、第三方包）
- 内部包是指不能被外部import的包（GoPath模式或非域名开头的当前项目包名）
- 带域名的包名都属于第三方包，不区分是否是当前项目内部包
- 包名与git路径名不一致或存在冲突时使用别名，别名命名规范与包命名规范保持一致
- 【可选】第三方包包名不符合规范可使用别名修正
- 【可选】匿名包引用建议使用新分组并添加注释说明
- 例外包：embed包内嵌外部数据时不需要注释

## 错误处理规范

### 【必须】Error处理
- error作为函数返回值时必须进行处理，或明确忽略
- error必须是函数的最后一个返回参数
- 错误描述不需要标点结尾
- 采用独立的错误流进行处理，避免与其他变量组合逻辑判断
- 推荐使用 `errors.New("xxxx")` 生成简单错误
- Go 1.13以上推荐使用 `fmt.Errorf("module xxx: %w", err)`

### 【必须】Panic处理
- 禁止使用panic进行一般错误处理，使用error和多返回值
- 可使用panic对不变量进行断言
- func init()及其调用的函数中初始化失败影响程序运行时可以panic
- 全局变量初始化调用的函数中初始化失败影响程序运行时可以panic（如regexp.MustCompile、template.Must）
- 导出方法一般不允许panic，必须panic的方法应使用MustXXX命名并在文档中说明
- 不建议使用log.Fatal进行断言

### 【必须】Recover处理
- 必须在defer中使用
- 在业务逻辑中一般不需要使用recover
- recover用于捕获具有明确类型的panic，禁止滥用recover捕获全部类型的异常
- recover返回的是interface{}，不要假设其是error，不要将返回值命名为err

## 注释规范

### 【必须】注释总则
- 在编码阶段同步写好变量、函数、包注释，注释可通过godoc导出生成文档
- 程序中每一个被导出的（大写的）名字，都应该有一个文档注释
- 非导出类型的方法可以没有文档注释，但需要质疑该方法可导出的必要性
- 所有注释掉的代码在提交code review前都应该被删除，除非添加注释说明为什么不删除并标明后续处理建议

### 【必须】包注释
- 每个包都应该有一个包注释（main包除外）
- 包如果有多个go文件，只需要出现在一个go文件中（一般是和包同名的文件）
- 格式："// Package 包名 包信息描述"

### 【必须】结构体注释
- 每个导出的结构体或接口都必须有注释说明
- 格式："// 结构体名 结构体信息描述"
- 结构体内导出成员变量如意义不明确需要注释

### 【必须】方法注释
- 每个导出的函数或方法都必须有注释
- 格式："// 函数名 函数信息描述"
- 例外方法：Write、Read、ServeHTTP、String、Unwrap、Error、Len、Less、Swap

### 【必须】变量和常量注释
- 每个需要导出的常量和变量都必须有注释说明
- 该注释对常量或变量进行简要介绍，放在常量或变量定义的前一行
- 大块常量或变量定义时，可在前面注释一个总的说明，然后每一行常量的末尾详细注释该常量的定义
- 格式："// 变量名 变量信息描述"，斜线后面紧跟一个空格

### 【必须】类型注释
- 每个导出的类型定义和类型别名都必须有注释说明
- 格式："// 类型名 类型信息描述"

## 命名规范

### 【推荐】包命名
- 保持package的名字和目录一致
- 尽量采取有意义、简短的包名，尽量不要和标准库冲突
- 包名应该为小写单词，不要使用下划线或者混合大小写，使用多级目录来划分层级
- 包名可谨慎地使用缩写，当缩写是程序员广泛熟知的词时可以使用（如strconv、syscall、fmt）
- 项目名可以通过中划线来连接多个单词
- 简单明了的包命名，如：time、list、http
- 不要使用无意义的包名，如：util、common、misc、global（xx/util/encryption这样的包名是允许的）

### 【必须】文件命名
- 采用有意义、简短的文件名
- 使用小写，用下划线分割单词

### 【必须】结构体命名
- 采用驼峰命名方式，首字母根据访问控制采用大写或小写
- 结构体名应该是名词或名词短语，如Customer、WikiPage、Account、AddressParser，它不应是动词
- 避免使用Data、Info这类意义太宽泛的结构体名
- 结构体的声明和初始化格式采用多行

### 【推荐】接口命名
- 单个函数接口以er作为后缀（如Reader、Writer）
- 两个函数接口综合两个函数名
- 三个以上函数接口类似结构体命名

### 【必须】变量命名
- 变量名必须遵循驼峰式，首字母根据访问控制决定使用大写或小写
- 特有名词时，需要遵循以下规则：
  - 如果变量为私有，且特有名词为首个单词，则使用小写，如apiClient
  - 其他情况都应该使用该名词原有的写法，如APIClient、repoID、UserID
  - 错误示例：UrlArray，应该写成urlArray或者URLArray
- 私有全局变量和局部变量规范一致，均以小写字母开头
- 代码生成工具自动生成的代码可排除此规则（如xxx.pb.go里面的Id）
- 变量名更倾向于选择短命名，特别是对于局部变量，变量的使用和声明位置越远，变量名就需要具备越强的描述性

### 【必须】常量命名
- 常量均需遵循驼峰式
- 如果是枚举类型的常量，需要先创建相应类型
- 私有全局常量和局部变量规范一致，均以小写字母开头

### 【必须】函数命名
- 函数名必须遵循驼峰式，首字母根据访问控制决定使用大写或小写
- 代码生成工具自动生成的代码可排除此规则（如协议生成文件xxx.pb.go，gotests自动生成文件xxx_test.go里面的下划线）

## 控制结构规范

### 【推荐】if语句
- 接受初始化语句建立局部变量
- 判断顺序：变量在左，常量在右
- bool类型变量直接进行真假判断

### 【推荐】for语句
- 采用短声明建立局部变量

### 【必须】range语句
- 只需要key时丢弃第二个值
- 只需要value时第一项置为下划线

### 【必须】switch语句
- 要求必须有default

### 【推荐】return语句
- 尽早return，一旦有错误发生，马上返回

### 【必须】goto语句
- 业务代码禁止使用goto，其他框架或底层源码推荐尽量不用

## 函数规范

### 【推荐】函数参数
- 函数返回相同类型的两个或三个参数，或者如果从上下文中不清楚结果的含义，使用命名返回，其它情况不建议使用命名返回
- 传入变量和返回变量以小写字母开头
- 参数数量均不能超过5个
- 尽量用值传递，非指针传递
- 传入参数是map、slice、chan、interface不要传递指针

### 【必须】defer规范
- 当存在资源管理时，应紧跟defer函数进行资源的释放
- 判断是否有错误发生之后，再defer释放资源
- 禁止在循环中使用defer

### 【推荐】方法接收器
- 推荐以类名首字母小写作为接收器命名
- 函数超过20行时不要用单字符
- 【必须】不能采用me、this、self等易混淆名称

### 【必须】嵌套深度
- 嵌套深度不能超过4层

### 【推荐】变量声明
- 变量声明尽量放在第一次使用前面，遵循就近原则

### 【必须】魔法数字
- 魔数应使用常量或变量做替代
- 魔数特征：缺乏解释或命名的表示相同含义的独特数值，影响可读性；在程序中出现多次，当数值改变时可能要改不只一个地方
- 正确识别魔数：只要在上下文中能让人一眼明白其含义，并且基本没有需要改变的可能，就不会被认为是魔术数字
- 常见非魔数例子：一元二次方程判别式公式中的4、取模运算中的2、循环中的0和1、程序错误退出的1等

## 单元测试规范

### 【必须】测试文件规范
- 单元测试文件名命名规范为example_test.go
- 测试用例的函数名称必须以Test开头，例如TestExample
- 如果存在func Foo，单测函数可以带下划线，为func Test_Foo
- 如果存在func (b *Bar) Foo，单测函数可以为func TestBar_Foo，下划线不能出现在前面描述情况以外的位置
- 单测文件行数限制是普通文件的2倍，即1600行；单测函数行数限制也是普通函数的2倍，即为160行
- 圈复杂度、列数限制、import分组等其他规范细节和普通文件保持一致
- 由于单测文件内的函数都是不对外的，所有可导出函数可以没有注释，但是结构体定义时尽量不要导出

## 依赖管理规范

### 【必须】Go Modules
- Go 1.11以上必须使用go modules模式
- 【推荐】module name使用git.woa.com/group/repo格式
- 【推荐】不提交vendor目录
- 【推荐】go.sum文件必须提交

## 应用服务规范

### 【推荐】文档要求
- 应用服务建议有README.md
- 包括服务描述、使用方法、部署要求、环境依赖等

### 【必须】测试要求
- 应用服务必须要有接口测试
- 每个重要的可导出函数都要编写测试用例

## 工具推荐
- gofmt：大部分格式问题可以通过gofmt解决，自动格式化代码，保证所有go代码与官方推荐格式保持一致
- goimports：在gofmt基础上增加了自动删除和引入包
- go vet：静态分析工具，可以帮助静态分析源码存在的各种问题，如多余的代码、提前return的逻辑、struct的tag是否符合标准等
- golint：类似javascript中的jslint的工具，主要功能是检测代码中不规范的地方 

## 项目规范

### 项目结构指南：
- 使用一致的项目布局：
  - cmd/: 应用程序入口点
  - internal/: 核心应用逻辑（不对外公开）
  - pkg/: 共享工具和包
  - api/: gRPC/REST传输定义和处理程序
  - configs/: 配置模式和加载
  - test/: 测试工具、模拟和集成测试
- 当提高清晰度和内聚性时，按功能组织代码。
- 将逻辑与特定于框架的代码解耦。

### 开发最佳实践：
- 编写具有单一职责的**短小聚焦函数**。
- 始终**显式检查和处理错误**，使用包装错误以实现可追溯性（'fmt.Errorf("context: %w", err)'）。
- 避免**全局状态**；使用构造函数注入依赖项。
- 利用**Go的上下文传播**进行请求范围的值、截止日期和取消。
- 安全使用**goroutines**；使用通道或同步原语保护共享状态。
- **延迟关闭资源**并小心处理，以避免泄漏。

### 安全性和弹性：
- 严格应用**输入验证和净化**，特别是对来自外部来源的输入。
- 对**JWT、cookies**和配置设置使用安全默认值。
- 通过明确的**权限边界**隔离敏感操作。
- 在所有外部调用上实现**重试、指数回退和超时**。
- 对服务进行**断路器和速率限制**保护。
- 考虑实现**分布式速率限制**以防止跨服务滥用（例如使用Redis）。

### 测试：
- 使用表驱动模式和并行执行编写**单元测试**。
- 使用生成的或手动编写的模拟对象**干净地模拟外部接口**。
- 将**快速单元测试**与较慢的集成和端到端测试分开。
- 确保对每个导出函数进行**测试覆盖**，包括行为检查。
- 使用像 'go test -cover' 这样的工具确保足够的测试覆盖率。

### 文档和标准：
- 使用**GoDoc风格的注释**为公共函数和包编写文档。
- 为服务和库提供简明的**README**。
- 维护一个 'CONTRIBUTING.md' 和 'ARCHITECTURE.md' 来指导团队实践。
- 使用 'go fmt'、'goimports' 和 'golangci-lint' 强制命名一致性和格式化。

### 使用OpenTelemetry进行可观测性（如适用）：
- 使用**OpenTelemetry**进行分布式跟踪、度量和结构化日志记录。
- 在所有服务边界（HTTP、gRPC、DB、外部API）上启动和传播跟踪**span**。
- 始终将 'context.Context' 附加到span、日志和度量导出。
- 使用**otel.Tracer**创建span和**otel.Meter**收集度量。
- 在span中记录重要属性，如请求参数、用户ID和错误消息。
- 通过将跟踪ID注入结构化日志实现**日志关联**。
- 将数据导出到**OpenTelemetry Collector**、**Jaeger**或**Prometheus**。

### 跟踪和监控最佳实践（如适用）：
- 跟踪所有**传入请求**，并通过内部和外部调用传播上下文。
- 使用**中间件**自动为HTTP和gRPC端点添加仪器。
- 使用**自定义span**标记慢速、关键或易出错的路径。
- 通过关键指标（请求延迟、吞吐量、错误率、资源使用）监控应用程序健康状况。
- 定义**SLI**（例如请求延迟 < 300ms）并使用**Prometheus/Grafana**仪表板跟踪。
- 使用强大的警报管道对关键条件（例如高5xx率、DB错误、Redis超时）进行警报。
- 避免标签和跟踪中的过度**基数**；保持可观察性开销最小。
- 适当使用**日志级别**（info、warn、error），并以JSON格式发出日志以供可观察性工具接收。
- 在所有日志中包含唯一的**请求ID**和跟踪上下文以进行关联。

### 性能：
- 使用**基准测试**跟踪性能回归并识别瓶颈。
- 最小化**分配**并避免过早优化；在调整之前进行性能分析。
- 为监控运行时行为而对关键区域（DB、外部调用、重计算）进行仪器化。

### 并发和Goroutines：
- 确保**安全使用goroutines**，并使用通道或同步原语保护共享状态。
- 使用上下文传播实现**goroutine取消**以避免泄漏和死锁。

### 工具和依赖项：
- 依赖于**稳定、最小的第三方库**；在可行的情况下优先使用标准库。
- 使用**Go模块**进行依赖管理和可重现性。
- 为确定性构建**版本锁定依赖项**。
- 在CI流水线中集成**linting、测试和安全检查**。

### 关键约定：
1. 优先考虑**可读性、简单性和可维护性**。
2. 为**变更**设计：隔离业务逻辑并最小化框架依赖。
3. 强调清晰的**边界**和**依赖反转**。
4. 确保所有行为都是**可观察、可测试和有文档记录**。
5. 为测试、构建和部署**自动化工作流**。